//- Coins Select Option

if(coinsDepositList)
	- coinsDepositList.sort((a, b) => a[0].localeCompare(b[0]));

	- var networks = []
	- coinsDepositList.forEach(coin => {
		- var network = coin[0].split('-')[1]
		- if (!networks.includes(network)) {
			- networks.push(network)
		- }
	- })
	- networks.sort((a, b) => a[0].localeCompare(b[0]));

	br

	label Coin
		input(type="radio", name="search-type", value="coin")
	
	label Network
		input(type="radio", name="search-type", value="network")   

	label All
		input(type="radio", name="search-type", value="all", checked)

	br
	input#search-input(type="text", placeholder="Search coins or networks...")
	br
	br
	
	label Select Coin Network (#{networks.length})
	br
	select(name="network_filter")
		option(value="all" selected) All Networks
			- networks.forEach(network => {
			option(value=network)= network
		- })

	br
	br
	label#text Select Coin
	br
	select(name="payWith")
		each coin in coinsDepositList
			option(value=coin) #{coin[0]}
			//- option(value=coin) #{coin[0].split('-')[0]}


script.
	document.addEventListener('DOMContentLoaded', function() {
		const networkSelect = document.querySelector('select[name="network_filter"]');
		const payWithSelect = document.querySelector('select[name="payWith"]');
		const searchInput = document.getElementById('search-input');
		const searchTypeRadios = document.querySelectorAll('input[name="search-type"]');

		let currentSearchType = 'coin'; // default

		// Update search type when radio changes
		searchTypeRadios.forEach(radio => {
			radio.addEventListener('change', () => {
				currentSearchType = radio.value;
				filterOptions();
			});
		});

		function filterOptions() {
			const selectedNetwork = networkSelect.value;
			const searchTerm = searchInput.value.toLowerCase();

			const options = Array.from(payWithSelect.options);
			let firstVisibleOption = null;
			let counter = 0;

			options.forEach(option => {
				const optionValue = JSON.parse(option.value); 
				const optionNetwork = optionValue[0].split('-')[1];
				const optionCoinName = optionValue[0].split('-')[0]; 
				const optionVisibility = optionValue[2];

				let matchesSearch = false;

				switch(currentSearchType) {
					case 'coin':
						// Only match coin names
						matchesSearch = optionCoinName.toLowerCase().includes(searchTerm);
						break;
					case 'network':
						// Only match network names
						matchesSearch = optionNetwork.toLowerCase().includes(searchTerm);
						break;
					case 'all':
						// Match either coin or network
						matchesSearch = 
							optionCoinName.toLowerCase().includes(searchTerm) ||
							optionNetwork.toLowerCase().includes(searchTerm);
						break;
				}

				if ((selectedNetwork === 'all' || optionNetwork === selectedNetwork) && matchesSearch) {
					option.style.display = '';
					if (firstVisibleOption === null) {
						firstVisibleOption = option.value;
					}
					if(optionVisibility === false){
						option.disabled = true;
					}
					counter++;
				} else {
					option.style.display = 'none';
				}
			});

			document.getElementById('text').innerText = "Select coin ("+counter+")";
			
			if (firstVisibleOption !== null) {
				payWithSelect.value = firstVisibleOption;
			}
		}

		networkSelect.addEventListener('change', filterOptions);
		searchInput.addEventListener('input', filterOptions);

		filterOptions();
	});
